<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Unit Testing</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="swift-code.css">

  <link href="https://fonts.googleapis.com/css?family=Montserrat|Playball|Playfair+Display:700" rel="stylesheet">
</head>

<body>
  <header class="home-banner">
    <h1 class="blog-title">Swifty</h1>
    <h2 class="blog-description">Weekly swift articles covering actual useful skills with short concise posts</h2>
  </header>

  <article class="container blog-article">
    <header>
      <div class="date-stamp">
        <time datetime="2019-06-29">Jun 29th 2019</time> -
        <address class="author"><a rel="author" href="">Declan McKenna</a></address>
      </div>
      <h1>Unit Testing <br class="responsive-break">
        Best Practices</h1>
    </header>
    <p>When I first learnt how to unit test every tutorial I came across would show me how to write a test for a simple model
      and it seemed pretty straight forward.</p>
      <p>When I tried to apply what I learnt in my project I soon encountered a lot
      of difficulties when trying to test:</p>
    <ul>
      <li>ViewControllers</li>
      <li>Private functions</li>
      <li>Static functions</li>
      <li>Network calls</li>
      <li>UserDefaults</li>
      <li>"Legacy code"</li>
    </ul>
    <p>Unit testing isn’t nearly as simple as it first appears. I feel this is one of the main reasons so many teams
      have little to no coverage in their projects.
      Yet having good coverage is vital to having a maintainable project.</p>
    <blockquote>"Unit tests keep our code flexible, maintainable and reusable. Without them every change is a
      possible bug."<footer>Uncle Bob - <cite>Clean Code</cite></footer>
    </blockquote>


    <p>Over the coming series of blog posts I will attempt to cover the questions above when it comes to unit
      testing in Xcode.</p>
      <p>For now we will go over some overarching concepts I have found very useful mostly taken from Robert Martin’s
      excellent book <cite>Clean Code</cite>.</p>

    <h2>F.I.R.S.T</h2>
    <p>All tests should follow the FIRST principles</p>

    <h3>Fast</h3>
    <p>We want to run these tests regularly and often by smashing <em>command U</em> whenever we’ve made changes or we're
      about to commit our work.</p>
      <p>For this to work we need our tests to be fast.
      <br>How fast is fast? We’re going to be
      writing a lot of tests so at the very minimum a test should run in less than 0.1 seconds.</p>

    <h3>Independent</h3>
    <p>Don’t write tests that depend on each other.</p>
      <p>Xcode actively helps us with this. Every function in an XCTestCase class that begins with “test” will receive a
      new instance of your test class so no instance variables will be carried over.</p>

      <p><code>setup()</code> and <code>teardown()</code> can be used to clear persistent resources but it would be better
      still to mock them. </p>

      <p>You should be able to run your tests in any order and have them pass.</p>

    <h3>Repeatable</h3>
    <p>Tests should run on any environment.</p>
    <p>If your unit tests only work on your laptop, your companies VPN or with a
      network connection they can’t be run reliably and your team will second guess why they’ve failed or ignore them.</p>

    <h3>Self-Validating</h3>
    <p>Tests should simply fail or pass and not rely on a log.</p>

    <p>
      I slipped up on this point when writing one of my first “unit tests” which tested the parsing of phone numbers from
      email text. It had a giant log with the % of phone numbers we parsed alongside a print out of all the ones which had
      failed and a spreadsheet I’d keep up to date with the results for each version of our app.</p>

      <p>This was an unnecessary manual process which made the tests unmaintainable and required inside
        knowledge to utilize</p>
        <p>If these tests had been written individually the name of the test would immediately tell the user
        what had broke.</p>

    <h3>Timely</h3>
    <p>Write tests with all code you commit.</p>
      <p>If you do it afterwards your production code may be difficult to test especially once more functionality is added to it</p>

    <h2>Clean Tests</h2>

    <p>Do not adopt a dual standard where readability is neglected for tests.</p>

    <p>As your code changes your tests will have to
      change. People who did not initially write them will have to understand them so that they can adapt, extend,
      or remove them.</p>

      <p>XCTest classes can and should have instance
      variables and helper functions to enhance readability and reduce repetition.</p>

    <h2>Smaller Tests</h2>
    <p>Minimize the number of asserts and test just one concept per test function.</p>
    <p>Smaller tests are easier to read and give clearer failure results.
      Any repetitive setup involved in doing this can be handled by <code>setup()</code> or
      private helper functions</p>

    <figure>
      <pre>
      <code>
<span class="keyword">func</span> testAddMonths() {
    <span class="keyword">let</span> may31 = <span class="type">SwiftyDate</span>(day: <span class="number">31</span>, month: <span class="number">5</span>, year: <span class="number">2019</span>)

    <span class="keyword">let</span> addMonthResult = may31.<span class="call">addMonths</span>(<span class="number">1</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">day</span>, <span class="number">30</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">month</span>, <span class="number">6</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">year</span>, <span class="number">2019</span>)

    <span class="keyword">let</span> addMonthResult2 = may31.<span class="call">addMonth</span>(<span class="number">2</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult2.<span class="property">day</span>, <span class="number">31</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult2.<span class="property">month</span>, <span class="number">7</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult2.<span class="property">year</span>, <span class="number">2019</span>)

    <span class="keyword">let</span> june30 = <span class="type">SwiftyDate</span>(day: <span class="number">30</span>, month: <span class="number">6</span>, year: <span class="number">2019</span>)
    <span class="keyword">let</span> addMonthResult3 = june30.<span class="call">addMonths</span>(<span class="number">1</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult3.<span class="property">day</span>, <span class="number">30</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult3.<span class="property">month</span>, <span class="number">7</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult3.<span class="property">year</span>, <span class="number">2019</span>)
 }
</code>
</pre>
      <figcaption>Bad: Three different scenarios bundled in to one test</figcaption>
    </figure>
    <figure>
      <pre>
      <code>
<span class="keyword">func</span> testDay31To30DayMonthJump() {
    <span class="keyword">let</span> addMonthResult = may31.<span class="call">addMonths</span>(<span class="number">1</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">day</span>, <span class="number">30</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">month</span>, <span class="number">6</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">year</span>, <span class="number">2019</span>)
}

<span class="keyword">func</span> test31st2MonthJumpThroughA30DayMonth() {
    <span class="keyword">let</span> addMonthResult = may31.<span class="call">addMonths</span>(<span class="number">2</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">day</span>, <span class="number">31</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">month</span>, <span class="number">7</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">year</span>, <span class="number">2019</span>)
}

<span class="keyword">func</span> testDay30To31DayMonthJump() {
    <span class="keyword">let</span> addMonthResult = june30.<span class="call">addMonths</span>(<span class="number">1</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">day</span>, <span class="number">30</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">month</span>, <span class="number">7</span>)
    <span class="call">XCTAssertEqual</span>(addMonthResult.<span class="property">year</span>, <span class="number">2019</span>)
}
</code>
</pre>
      <figcaption>Good: Tests split up for different scenarios</figcaption>
    </figure>

    <h2>Enable Test Coverage</h2>
    <p>Using a coverage tool allows you to immediately see gaps in your testing strategy.</p>
      <p>Xcode has a built in coverage tool which at the time of writing is not enabled by default.
    </p>
    <figure>
      <img src="images/unit-testing-best-practices/scheme-screenshot.png" alt="Scheme settings screenshot">
      <figcaption>Enable code coverage by going to your scheme -> <em>edit schemes -> Test -> Options</em> and check <em>Gather coverage</em></figcaption>
    </figure>
    <figure>
      <img src="images/unit-testing-best-practices/coverage-screenshot.png" alt="Test coverage report screenshot">
      <figcaption>View your projects coverage within the reports tab <em>cmd-9</em></figcaption>
    </figure>
    <figure>
      <img src="images/unit-testing-best-practices/untested-highlighting-screenshot.png" alt="Xcode untested code highlighting screenshot">
      <figcaption>Xcode will highlight untested functions with a red margin</figcaption>
    </figure>
    <h2>Setup Continuous Integration</h2>
    <p>Tools such as Jenkins or Travis can run your tests when someone makes a Pull Request and automatically block the PR
      if the tests failed.</p>
      <p>This is a vital tool to have as without it it’s possible to merge branches with failing tests.
      If tests can be ignored then there’s no point in having them.</p>

    <h2>Test Behaviours rather than functions</h2>
    <p>Just because a function has test coverage doesn't mean it's fully tested.</p>
      <p>Push your code to the limit and write tests for every edge case you can think of. It's better to have too
        many tests than too few.

      <p>The date tests above are a good example of this.</p>
      <p>One test for <code>addMonths()</code> will satisfy code coverage tools that the function is tested but there is
      far more behaviour to be tested. For example what date do we land on when we add one month to January 30th?</p>

    <h2>Conclusion</h2>
    <p>Testing isn’t as straight forward as most tutorials will tell you, this article doesn’t come close to covering all
      the difficulties you can potentially face either.</p>
      <p>However it’s one of the most important skills you can learn. It is universally
      needed across all languages and platforms and is probably the easiest tell tale sign of picking out the good devs
      from the great devs.</p>

      <p>Stay tuned and we’ll have more articles diving in to testing in more detail in the coming
      weeks.</p>

  </article>
</body>

</html>
