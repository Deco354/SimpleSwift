<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Unit Testing</title>
  <link rel="stylesheet" href="styles.css">

  <link href="https://fonts.googleapis.com/css?family=Montserrat|Playball|Playfair+Display:700" rel="stylesheet">
</head>

<body>
  <header class="home-banner">
    <h1 class="blog-title">Swifty</h1>
    <h2 class="blog-description">Weekly swift articles covering actual useful skills with short concise posts</h2>
  </header>

  <article class="container">
    <h1>Unit Testing <br class="responsive-break">
      Best Practices</h1>
    <p>When I first learnt how to unit test I looked up a tutorial showing me how to write a test for a simple model
      and it seemed pretty straight forward. When I tried to apply what I learnt in my project I soon encountered a lot
      of difficulties.</p>
    <ul>
      <li>How do I test ViewControllers?</li>
      <li>How do I test private functions?</li>
      <li>How do I test static functions?</li>
      <li>How do I test network calls?</li>
      <li>How do I test UserDefaults?</li>
      <li>How do I make my class testable?</li>
    </ul>
    <p>Unit testing isn’t nearly as simple as most tutorials make out and it’s one of the main reasons so many teams
      have little to no coverage in their projects.
      Yet having good coverage is vital to having a maintainable project.</p>
    <blockquote>Unit tests keep our code flexible, maintainable and reusable. Without them every change is a
      possible bug.</blockquote>
    <footer>Uncle Bob - <cite>Clean Code</cite></footer>

    <p>Over the coming series of blog posts I will attempt to cover the questions above when it comes to unit
      testing in Xcode. In this article I’ll broach some overarching concepts mostly taken from Robert Martin’s
      excellent book <cite>Clean Code</cite>.</p>
    <h2>F.I.R.S.T</h2>
    <p>All tests should follow the FIRST principles</p>
    <h3>Fast</h3>
    <p>We want to run these tests regularly and often by smashing command U whenever we’ve made changes or we're
      about to commit our work. For this to work we need our tests to be fast. How fast is fast? We’re going to be
      writing a lot of tests so at the very minimum a test should be under 0.1 seconds.</p>
    <h3>Independent</h3>
    <p>Don’t write tests that depend on each other.
      Xcode actively helps us with this, every function in an XCTestCase class that begins with “test” will receive a
      new instance of your test class so no variables can be carried over.
      <code>setup()</code> and <code>teardown()</code> can be used to clear persistent resources but it would be better
      still to mock them. You should be able to run your tests in any order and have them pass.</p>

    <h3>Repeatable</h3>
    <p>Tests should run on any environment. If your unit tests only work on your laptop, your companies VPN or with a
      network connection they can’t be run reliably and your team will second guess why they’ve failed or ignore them.</p>

    <h3>Self-Validating</h3>
    <p>Tests should simply fail or pass and not rely on a log.
      <br>
      I slipped up on this point when writing one of my first “unit tests” which tested the parsing of phone numbers from
      email text. It had a giant log with the % of phone numbers we parsed alongside a print out of all the ones which had
      failed and a spreadsheet I’d keep up to date the results for each version of our app.</p>

    <h3>Timely</h3>
    <p>Write them with, or better yet before your code. If you do it after your production code may be difficult to test.</p>

    <h2>Clean Tests</h2>

    <p>Do not adopt a dual standard where readability is neglected for tests. As your code changes your tests will have to
      change people who did not initially write them will have to understand them so that they can adapt them, extend them
      or remove tests that are no longer relevant without losing coverage. XCTest classes can and should have instance
      variables and helper functions to enhance readability and reduce repetition.</p>

    <h2>Smaller Tests</h2>
    <p>Minimize the number of asserts and test just one concept per test function. Smaller tests are easier to read and
      give clearer failure results. Any repetitive setup involved in doing this can be handled by <code>setup()</code> or
      private helper functions</p>

    <h4>Don't</h4>
    <script src="https://gist.github.com/Deco354/9415a42bc6b17fbae38876e4f9aae3f9.js"></script>
    <h4>Do</h4>
    <script src="https://gist.github.com/Deco354/406790ab3a097d2c4a5c55af016977a7.js"></script>
    <h2>Enable Test Coverage</h2>
    <p>Using a coverage tool allows you to immediately see gaps in your testing strategy.
      <br>
      Xcode has a built in coverage tool which at the time of writing is not enabled by default.
      Enable it by going to your scheme (to the right of the stop button) -> edit schemes -> Test ->
      Options and check “Gather coverage”.</p>
    <img src="images/unit-testing-best-practices/scheme-screenshot.png" alt="Scheme settings screenshot">
    <br>
    <p>Once this is enabled you can view your projects coverage within the reports tab <em>(command - 9)</em></p>
    <img src="images/unit-testing-best-practices/coverage-screenshot.png" alt="Test coverage report screenshot">
    <br>
    <p>Better yet Xcode will even highlight untested functions with a red border as seen below.</p>
    <img src="images/unit-testing-best-practices/untested-highlighting-screenshot.png" alt="XCode untested code highlighting screenshot">

    <h2>Setup Continuous Integration</h2>
    <p>Tools such as Jenkins or Travis can run your tests when someone makes a Pull Request and automatically block the PR
      if the tests failed. This is a vital tool to have as without it it’s possible to merge branches with failing tests.
      If tests can be ignored then there’s no point in having them.</p>

    <h2>Test Behaviours rather than functions</h2>
    <p>As nice as it is to have a test coverage tool you often need to do much more than just test that the function works
      under normal conditions. Push it to the limit and put edge cases in which will really push your code to the limit.
      The date tests above are a good example of this.</p>

    <h2>Conclusion</h2>
    <p>Testing isn’t as straight forward as most tutorials will tell you, this article doesn’t come close to covering all
      the difficulties you can potentially face either. It’s one of the most important skills you can learn, is universally
      needed across all languages and platforms and is probably the easiest tell tale sign of picking out the good devs
      from the great devs. Stay tuned and we’ll have more articles diving in to testing in more detail in the coming
      weeks.</p>

  </article>
</body>

</html>
